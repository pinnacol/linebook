= Linebook

Quick and easy manifests.

== Description

Linebook aggregates files spread across multiple directories and generates a
manifest for lookup using relative paths. Manifests simplify the use of
resources distributed as gems, or developed in multiple directories.

For example:

  /pwd/lib/one.rb
  /gem/a/lib/two.rb
  /gem/b/lib/three.rb

Becomes:

  {
    'one.rb'   => '/pwd/lib/one.rb', 
    'two.rb'   => '/gem/a/lib/two.rb',
    'three.rb' => '/gem/b/lib/three.rb'
  }

== Usage

Linebook generates a manifest from configs that specify the paths and patterns
to glob. These configs can come from anywhere but typically they're put into a
config file.

  Linebook('patterns' => 'lib/*.rb', 'path' => '/pwd', 'gems' => 'a:b')
  # => {
  #   'one.rb'   => '/pwd/lib/one.rb', 
  #   'two.rb'   => '/gem/a/lib/two.rb',
  #   'three.rb' => '/gem/b/lib/three.rb'
  # }

See below for variations of the config.

== Config

Linebook uses directories, base paths, and patterns to glob for full paths and
determine the relative paths used in the manifest. The config literally
defines (in a highly redundant way) what to glob, and how to slice the
results. A fully-expanded config looks like this:

  { 'paths' => [['/dir', 'base', 'pattern']] }

And corresponds to this pseudocode:

  for each path
    glob '/dir/base/pattern'
    for each result
      record result using path relative to '/dir/base'
      (override previous result, if it exists)

Configs can be written in several compact forms that expand into the full
form. The expansion works like this (pretend you're on a system where case
matters; configs can be written with any combination of the following):

  # start
  { 'patterns' => 'base/pattern:BASE/PATTERN',
    'paths'    => '/dir:/DIR' }
  
  # split
  { 'patterns' => [['base', 'pattern'], ['BASE', 'PATTERN']]
    'paths'    => ['/dir', '/DIR'] }
  
  # combine
  { 'paths'    => [
      ['/dir', 'base', 'pattern'], 
      ['/dir', 'BASE', 'PATTERN'],
      ['/DIR', 'base', 'pattern'],
      ['/DIR', 'BASE', 'PATTERN']]}

When order doesn't matter the patterns can be written as a hash:

  # multiple patterns per-base
  { 'patterns' => {'base' => 'pattern:PATTERN'} }
  
  # multiple bases (final order indeterminate)
  { 'patterns' => {'base' => 'pattern', 'BASE' => 'PATTERN'} }

When the paths point to gems, the gem names may be specified as 'gems' in the
same way as paths. The path to the latest version will be used; Linebook has
no notion of dependencies, so something like Bundler, RVM or personal
diligence needs to be used to ensure the latest version is the correct version
to use. Gems are considered before paths, so these are the same:

  { 'patterns' => 'base/pattern:BASE/PATTERN',
    'gems'     => 'name',
    'paths'    => '/dir' }

  { 'paths'    => [
      ['/path/to/name', 'base', 'pattern'], 
      ['/path/to/name', 'BASE', 'PATTERN'], 
      ['/dir', 'base', 'pattern'],
      ['/dir', 'BASE', 'PATTERN']]}

Lastly, you can manually override any result using 'manifest'. The manifest
hash is merged over the result of searching along each paths.

  { 'manifest'  => {'relative/path' => '/full/path'} }

== Design Note

Linebook uses a module rather than a class interface, which may seem peculiar.
Although Linebook is a standalone library, it was designed as the distribution
module for Linecook. Linecook needed a clean namespace to let users name
helpers as they please; Linebook was made without any internal constants for
that purpose.

Likewise the helper methods used by Linebook all start with a double
underscore, again to keep the module as clean as possible.

== Installation

Linebook is available as a gem on {Gemcutter}[http://gemcutter.org/gems/linebook]

  % gem install linebook

== Info 

Developer:: {Simon Chiang}[http://bahuvrihi.wordpress.com]
License:: {MIT-Style}[link:files/License_txt.html]