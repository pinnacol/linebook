require 'erb'

# Generated by Linecook, do not edit.
module Linebook
  module Shell
    require 'linebook/shell/unix'
    include Unix
    
    def self.extended(base)
      base.attributes 'linebook/shell'
      
      if shell = base.attrs['linebook']['shell']
        base.helpers shell
      end
      
      if os = base.attrs['linebook']['os']
        base.helpers os
      end
      
      super
    end
    
    def guess_target_name(source_name)
      next_target_name File.join("#{target_name}.d", File.basename(source_name))
    end
    
    def log_dir
      '/var/log/linecook'
    end
    
    def nest_opts(opts, default={})
      opts = default if opts.nil? || opts == true
      opts && block_given? ? yield(opts) : opts
    end
    
    # Backup a file.
    def backup(path, options={})
      backup_path = "#{path}.bak"
      if options[:mv]
        mv_f path, backup_path
      else
        cp_f path, backup_path
      end
      
      chmod 644, backup_path
      self
    end
    
    def _backup(*args, &block) # :nodoc:
      capture { backup(*args, &block) }
    end
    
    def directory(target, options={})
      not_if _directory?(target) do 
        mkdir_p target
      end 
      chmod options[:mode] || 755, target
      chown options[:user], options[:group], target
      self
    end
    
    def _directory(*args, &block) # :nodoc:
      capture { directory(*args, &block) }
    end
    
    # Installs a file from the package.
    def file(file_name, target, options={})
      source = file_path(file_name, guess_target_name(target))
      install(source, target, options)
      self
    end
    
    def _file(*args, &block) # :nodoc:
      capture { file(*args, &block) }
    end
    
    def group?(name)
      #  grep "^<%= name %>:" /etc/group >/dev/null 2>&1
      _erbout.concat "grep \"^"; _erbout.concat(( name ).to_s); _erbout.concat ":\" /etc/group >/dev/null 2>&1";
      self
    end
    
    def _group?(*args, &block) # :nodoc:
      capture { group?(*args, &block) }
    end
    
    def group(name, options={})
      not_if _group?(name) do
        groupadd name
      end
      self
    end
    
    def _group(*args, &block) # :nodoc:
      capture { group(*args, &block) }
    end
    
    def groupadd(name, options={})
      execute 'groupadd', name, options
      self
    end
    
    def _groupadd(*args, &block) # :nodoc:
      capture { groupadd(*args, &block) }
    end
    
    def groupdel(name, options={})
      execute 'groupdel', name, options
      self
    end
    
    def _groupdel(*args, &block) # :nodoc:
      capture { groupdel(*args, &block) }
    end
    
    def groupmod(name, options={})
      execute 'groupmod', name, options
      self
    end
    
    def _groupmod(*args, &block) # :nodoc:
      capture { groupmod(*args, &block) }
    end
    
    def groups(user, options={})
      sep = options[:sep]
      #  id -Gn <%= quote(user) %><% if sep %> | sed "s/ /<%= sep %>/g"<% end %>
      #  
      #  
      _erbout.concat "id -Gn "; _erbout.concat(( quote(user) ).to_s);  if sep ; _erbout.concat " | sed \"s/ /"; _erbout.concat(( sep ).to_s); _erbout.concat "/g\"";  end ; _erbout.concat "\n"
      _erbout.concat "\n"
      self
    end
    
    def _groups(*args, &block) # :nodoc:
      capture { groups(*args, &block) }
    end
    
    # Installs a file
    def install(source, target, options={})
      nest_opts(options[:backup], :mv => true) do |opts|
        only_if _file?(target) do
          backup target, opts
        end
      end
      
      nest_opts(options[:directory]) do |opts|
        directory File.dirname(target), opts
      end
      
      cp source, target
      chmod options[:mode] || 644, target
      chown options[:user], options[:group], target
      self
    end
    
    def _install(*args, &block) # :nodoc:
      capture { install(*args, &block) }
    end
    
    def package(name, version=nil)
      raise NotImplementedError
      self
    end
    
    def _package(*args, &block) # :nodoc:
      capture { package(*args, &block) }
    end
    
    def recipe(recipe_name)
      target_name = File.join('recipes', recipe_name)
      runlist = target_path "runlist.log"
      recipe_path = @package.registry.has_key?(target_name) ? 
        target_path(target_name) : 
        self.recipe_path(recipe_name, target_name)
      
      not_if %{grep -xqs "#{recipe_name}" "#{runlist}"} do
        target.puts %{echo "#{recipe_name}" >> "#{runlist}"}
        target.puts %{"#{shell_path}" "#{recipe_path}" $*}
        check_status
      end
      self
    end
    
    def _recipe(*args, &block) # :nodoc:
      capture { recipe(*args, &block) }
    end
    
    # Installs a template from the package.
    def template(template_name, target, options={})
      locals = options[:locals] || {}
      source = template_path(template_name, guess_target_name(target), locals)
      install(source, target, options)
      self
    end
    
    def _template(*args, &block) # :nodoc:
      capture { template(*args, &block) }
    end
    
    def user?(name)
      #  grep "^<%= name %>" /etc/passwd >/dev/null 2>&1
      _erbout.concat "grep \"^"; _erbout.concat(( name ).to_s); _erbout.concat "\" /etc/passwd >/dev/null 2>&1";
      self
    end
    
    def _user?(*args, &block) # :nodoc:
      capture { user?(*args, &block) }
    end
    
    def user(name, options={})
      not_if _user?(name) do
        useradd name
      end
      
      
      if groups = options[:groups]
        groups = groups.gsub('*') { "$(#{_groups(name, :sep => ',')})" }
        usermod name, :groups => groups
      end
      self
    end
    
    def _user(*args, &block) # :nodoc:
      capture { user(*args, &block) }
    end
    
    def useradd(name, options={})
      execute 'useradd', name, options
      self
    end
    
    def _useradd(*args, &block) # :nodoc:
      capture { useradd(*args, &block) }
    end
    
    def userdel(name, options={})
      execute 'userdel', name, options
      self
    end
    
    def _userdel(*args, &block) # :nodoc:
      capture { userdel(*args, &block) }
    end
    
    def usermod(name, options={})
      execute 'usermod', name, options
      self
    end
    
    def _usermod(*args, &block) # :nodoc:
      capture { usermod(*args, &block) }
    end
  end
end
