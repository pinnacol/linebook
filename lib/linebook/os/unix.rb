# Generated by Linecook

module Linebook
  module Os
    # Defines basic UNIX utilities, and UNIX-compliant functionality. See the
    # online {Open Group Specification of UNIX
    # }[http://pubs.opengroup.org/onlinepubs/000095399/toc.htm] and specifically
    # the {list of standard utilties
    # }[http://pubs.opengroup.org/onlinepubs/000095399/idx/utilities.html].
    module Unix
      require 'linebook/os/posix'
      include Posix
      
      def guess_target_name(source_name)
        target_dir  = File.dirname(target_name)
        name = File.basename(source_name)
        
        _package_.next_target_name(target_dir == '.' ? name : File.join(target_dir, name))
      end
      
      def close
        unless closed? 
          if @shebang ||= false
            section " (#{target_name}) "
          end
        end
        
        super
      end
      
      # Executes cat.
      def cat(*files)
        execute 'cat', *files
        chain_proxy
      end
      
      def _cat(*args, &block) # :nodoc:
        str = capture_str { cat(*args, &block) }
        str.strip!
        str
      end
      
      # Changes pwd using cd, for the duration of a block if given.
      def cd(dir=nil)
        if block_given?
          var = _package_.next_variable_name('cd')
          writeln %{#{var}=$(pwd)}
        end
      
        execute "cd", dir
      
        if block_given?
          yield
          execute "cd", "$#{var}"
        end
        chain_proxy
      end
      
      def _cd(*args, &block) # :nodoc:
        str = capture_str { cd(*args, &block) }
        str.strip!
        str
      end
      
      # Changes the file mode. The file mode may be specified as a String or a Fixnum.
      # If a Fixnum is provided, then it will be formatted into an octal string using
      # sprintf "%o".
      def chmod(mode, file, options={})
        unless mode.nil?
          if mode.kind_of?(Fixnum)
            mode = sprintf("%o", mode)
          end
          execute 'chmod', mode, file, options
        end
        chain_proxy
      end
      
      def _chmod(*args, &block) # :nodoc:
        str = capture_str { chmod(*args, &block) }
        str.strip!
        str
      end
      
      # Changes file ownership. A nil value as owner or group will preserve the
      # existing value.
      def chown(owner, group, file, options={})
        unless owner.nil? && group.nil?
          execute 'chown', "#{owner}:#{group}", file, options
        end
        chain_proxy
      end
      
      def _chown(*args, &block) # :nodoc:
        str = capture_str { chown(*args, &block) }
        str.strip!
        str
      end
      
      # Copies source to target.
      def cp(source, target, options={})
        execute 'cp', source, target, options
        chain_proxy
      end
      
      def _cp(*args, &block) # :nodoc:
        str = capture_str { cp(*args, &block) }
        str.strip!
        str
      end
      
      # Writes the date and time.
      def date(options={})
        execute 'date', options
        chain_proxy
      end
      
      def _date(*args, &block) # :nodoc:
        str = capture_str { date(*args, &block) }
        str.strip!
        str
      end
      
      # Checks that file exists and is a directory.
      def directory?(dir)
        #  [ -d "<%= dir %>" ]
        #  
        write "[ -d \""; write(( dir ).to_s); write "\" ]\n"
      
        chain_proxy
      end
      
      def _directory?(*args, &block) # :nodoc:
        str = capture_str { directory?(*args, &block) }
        str.strip!
        str
      end
      
      # Echo the args.
      def echo(*args)
        execute 'echo', *args
        chain_proxy
      end
      
      def _echo(*args, &block) # :nodoc:
        str = capture_str { echo(*args, &block) }
        str.strip!
        str
      end
      
      # Checks that file exists and is executable, or file is a directory that can be
      # searched.
      def executable?(file)
        #  [ -x "<%= file %>" ]
        #  
        write "[ -x \""; write(( file ).to_s); write "\" ]\n"
      
        chain_proxy
      end
      
      def _executable?(*args, &block) # :nodoc:
        str = capture_str { executable?(*args, &block) }
        str.strip!
        str
      end
      
      # Checks that file exists.
      def exists?(file)
        #  [ -e "<%= file %>" ]
        #  
        write "[ -e \""; write(( file ).to_s); write "\" ]\n"
      
        chain_proxy
      end
      
      def _exists?(*args, &block) # :nodoc:
        str = capture_str { exists?(*args, &block) }
        str.strip!
        str
      end
      
      # Checks that file exists and is a regular file.
      def file?(file)
        #  [ -f "<%= file %>" ]
        #  
        write "[ -f \""; write(( file ).to_s); write "\" ]\n"
      
        chain_proxy
      end
      
      def _file?(*args, &block) # :nodoc:
        str = capture_str { file?(*args, &block) }
        str.strip!
        str
      end
      
      # Perform a gsub using sed.  Intended for use in chains.
      def gsub(pattern, replacement, *args)
        unless args.last.kind_of?(Hash)
          args << {}
        end
        args.last[:e] = "s/#{pattern}/#{replacement}/g"
        sed(*args)
        chain_proxy
      end
      
      def _gsub(*args, &block) # :nodoc:
        str = capture_str { gsub(*args, &block) }
        str.strip!
        str
      end
      
      # Checks that file exists and is not empty.
      def has_content?(file)
        #  [ -s "<%= file %>" ]
        #  
        write "[ -s \""; write(( file ).to_s); write "\" ]\n"
      
        chain_proxy
      end
      
      def _has_content?(*args, &block) # :nodoc:
        str = capture_str { has_content?(*args, &block) }
        str.strip!
        str
      end
      
      # Checks that file exists and is a symbolic link.
      def link?(file)
        #  [ -L "<%= file %>" ]
        #  
        write "[ -L \""; write(( file ).to_s); write "\" ]\n"
      
        chain_proxy
      end
      
      def _link?(*args, &block) # :nodoc:
        str = capture_str { link?(*args, &block) }
        str.strip!
        str
      end
      
      # Link source to target.
      def ln(source, target, options={})
        execute 'ln', source, target, options
        chain_proxy
      end
      
      def _ln(*args, &block) # :nodoc:
        str = capture_str { ln(*args, &block) }
        str.strip!
        str
      end
      
      # List directory contents.
      def ls(file='.', options={})
        execute 'ls', file, options
        chain_proxy
      end
      
      def _ls(*args, &block) # :nodoc:
        str = capture_str { ls(*args, &block) }
        str.strip!
        str
      end
      
      # Make a directory.
      def mkdir(dir, options={})
        execute 'mkdir', dir, options
        chain_proxy
      end
      
      def _mkdir(*args, &block) # :nodoc:
        str = capture_str { mkdir(*args, &block) }
        str.strip!
        str
      end
      
      # Move source to target.
      def mv(source, target, options={})
        execute 'mv', source, target, options
        chain_proxy
      end
      
      def _mv(*args, &block) # :nodoc:
        str = capture_str { mv(*args, &block) }
        str.strip!
        str
      end
      
      # Writes the working directory name
      def pwd(options={})
        execute 'pwd', options
        chain_proxy
      end
      
      def _pwd(*args, &block) # :nodoc:
        str = capture_str { pwd(*args, &block) }
        str.strip!
        str
      end
      
      # Checks that file exists and is readable.
      def readable?(file)
        #  [ -r "<%= file %>" ]
        #  
        write "[ -r \""; write(( file ).to_s); write "\" ]\n"
      
        chain_proxy
      end
      
      def _readable?(*args, &block) # :nodoc:
        str = capture_str { readable?(*args, &block) }
        str.strip!
        str
      end
      
      # Remove directory entries.
      def rm(file, options={})
        execute 'rm', file, options
        chain_proxy
      end
      
      def _rm(*args, &block) # :nodoc:
        str = capture_str { rm(*args, &block) }
        str.strip!
        str
      end
      
      # Write a comment to delimit sections.  The comment takes the format:
      # 
      #   #### name ###
      def section(name="")
        n = (78 - name.length)/2
        str = "-" * n
        #  #<%= str %><%= name %><%= str %><%= "-" if name.length % 2 == 1 %>
        #  
        write "#"; write(( str ).to_s); write(( name ).to_s); write(( str ).to_s); write(( "-" if name.length % 2 == 1 ).to_s); write "\n"
      
        chain_proxy
      end
      
      def _section(*args, &block) # :nodoc:
        str = capture_str { section(*args, &block) }
        str.strip!
        str
      end
      
      # Execute sed.
      def sed(*args)
        execute 'sed', *args
        chain_proxy
      end
      
      def _sed(*args, &block) # :nodoc:
        str = capture_str { sed(*args, &block) }
        str.strip!
        str
      end
      
      # Sets the options to on (true) or off (false) as specified. If a block is given
      # then options will only be reset when the block completes.
      def set(options)
        if block_given?
          var = _package_.next_variable_name('set')
          patterns = options.keys.collect {|key| "-e #{key}" }.sort
          writeln %{#{var}=$(set +o | grep #{patterns.join(' ')})}
        end
      
        super
      
        if block_given?
          yield
          writeln %{eval "$#{var}"}
        end
        chain_proxy
      end
      
      def _set(*args, &block) # :nodoc:
        str = capture_str { set(*args, &block) }
        str.strip!
        str
      end
      
      # Sets the system time.
      def set_date(time=Time.now) 
        #  date -u <%= time.dup.utc.strftime("%m%d%H%M%Y.%S") %>
        #  <% check_status %>
        write "date -u "; write(( time.dup.utc.strftime("%m%d%H%M%Y.%S") ).to_s); write "\n"
        check_status 
        chain_proxy
      end
      
      def _set_date(*args, &block) # :nodoc:
        str = capture_str { set_date(*args, &block) }
        str.strip!
        str
      end
      
      def shebang(options={})
        @shebang = true
        #  #!<%= options[:program] || '/bin/sh' %>
        #  <% section %>
        #  
        #  usage="usage: %s: [-h]\n"
        #  while getopts "h" opt
        #  do
        #    case $opt in
        #    h  )  printf "$usage" $0
        #          printf "       %s   %s\n" "-h" "prints this help"
        #          exit 0 ;;
        #    \? )  printf "$usage" $0
        #          exit 2 ;;
        #    esac
        #  done
        #  shift $(($OPTIND - 1))
        #  
        #  <% check_status_function %>
        #  <% yield if block_given? %>
        #  
        #  <% if options[:info] %>
        #  echo >&2
        #  echo "###############################################################################" >&2
        #  echo "# $(whoami)@$(hostname):$(pwd):$0" >&2
        #  
        #  <% end %>
        #  <% section " #{target_name} " %>
        #  
        #  
        write "#!"; write(( options[:program] || '/bin/sh' ).to_s); write "\n"
        section 
        write "\n"
        write "usage=\"usage: %s: [-h]\\n\"\n"
        write "while getopts \"h\" opt\n"
        write "do\n"
        write "  case $opt in\n"
        write "  h  )  printf \"$usage\" $0\n"
        write "        printf \"       %s   %s\\n\" \"-h\" \"prints this help\"\n"
        write "        exit 0 ;;\n"
        write "  \\? )  printf \"$usage\" $0\n"
        write "        exit 2 ;;\n"
        write "  esac\n"
        write "done\n"
        write "shift $(($OPTIND - 1))\n"
        write "\n"
        check_status_function 
        yield if block_given? 
        write "\n"
        if options[:info] 
        write "echo >&2\n"
        write "echo \"###############################################################################\" >&2\n"
        write "echo \"# $(whoami)@$(hostname):$(pwd):$0\" >&2\n"
        write "\n"
        end 
        section " #{target_name} " 
        write "\n"
      
        chain_proxy
      end
      
      def _shebang(*args, &block) # :nodoc:
        str = capture_str { shebang(*args, &block) }
        str.strip!
        str
      end
      
      # Change file access and modification times.
      def touch(file, options={})
        execute 'touch', file, options
        chain_proxy
      end
      
      def _touch(*args, &block) # :nodoc:
        str = capture_str { touch(*args, &block) }
        str.strip!
        str
      end
      
      # Checks that file exists and is writable.
      def writable?(file)
        #  [ -w "<%= file %>" ]
        #  
        write "[ -w \""; write(( file ).to_s); write "\" ]\n"
      
        chain_proxy
      end
      
      def _writable?(*args, &block) # :nodoc:
        str = capture_str { writable?(*args, &block) }
        str.strip!
        str
      end
    end
  end
end
