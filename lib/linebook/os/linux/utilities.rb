# Generated by Linecook

module Linebook
  module Os
    module Linux
      module Utilities
        # Returns true if the group exists as determined by checking /etc/group.
        def group?(name)
          #  grep "^<%= name %>:" /etc/group >/dev/null 2>&1
          write "grep \"^"; write(( name ).to_s); write ":\" /etc/group >/dev/null 2>&1"
          chain_proxy
        end
        
        def _group?(*args, &block) # :nodoc:
          str = capture_str { group?(*args, &block) }
          str.strip!
          str
        end
        
        # Create a new group.
        def groupadd(group, options={})
          execute 'groupadd', group, options
          chain_proxy
        end
        
        def _groupadd(*args, &block) # :nodoc:
          str = capture_str { groupadd(*args, &block) }
          str.strip!
          str
        end
        
        # Delete a group.
        def groupdel(group)
          execute 'groupdel', group
          chain_proxy
        end
        
        def _groupdel(*args, &block) # :nodoc:
          str = capture_str { groupdel(*args, &block) }
          str.strip!
          str
        end
        
        # Modify a group.
        def groupmod(group, options={})
          execute 'groupmod', group, options
          chain_proxy
        end
        
        def _groupmod(*args, &block) # :nodoc:
          str = capture_str { groupmod(*args, &block) }
          str.strip!
          str
        end
        
        # Display a group.
        def groups(user)
          execute 'groups', user
          chain_proxy
        end
        
        def _groups(*args, &block) # :nodoc:
          str = capture_str { groups(*args, &block) }
          str.strip!
          str
        end
        
        # Copy files and set attributes.
        def install(source, dest, options={})
          execute 'install', source, dest, options
          chain_proxy
        end
        
        def _install(*args, &block) # :nodoc:
          str = capture_str { install(*args, &block) }
          str.strip!
          str
        end
        
        # Switches to the specified user for the duration of a block.  The current ENV
        # and pwd are preserved.
        def su(user='root', options={})
          path = capture_script(options) do
            functions.each do |function|
              writeln function
            end
            yield
          end
          execute 'su', user, path, :m => true
          chain_proxy
        end
        
        def _su(*args, &block) # :nodoc:
          str = capture_str { su(*args, &block) }
          str.strip!
          str
        end
        
        # Returns true if the user exists as determined by id.
        def user?(name)
          #  id <%= quote(name) %> >/dev/null 2>&1
          write "id "; write(( quote(name) ).to_s); write " >/dev/null 2>&1"
          chain_proxy
        end
        
        def _user?(*args, &block) # :nodoc:
          str = capture_str { user?(*args, &block) }
          str.strip!
          str
        end
        
        # Create a new user or update default new user information.
        def useradd(login, options={}) 
          execute 'useradd', login, options
          chain_proxy
        end
        
        def _useradd(*args, &block) # :nodoc:
          str = capture_str { useradd(*args, &block) }
          str.strip!
          str
        end
        
        # Delete a user account and related files.
        def userdel(login, options={}) 
          # TODO - look into other things that might need to happen before:
          # * kill processes belonging to user
          # * remove at/cron/print jobs etc. 
          execute 'userdel', login, options
          chain_proxy
        end
        
        def _userdel(*args, &block) # :nodoc:
          str = capture_str { userdel(*args, &block) }
          str.strip!
          str
        end
        
        # Modify a user account.
        def usermod(login, options={})
          execute 'usermod', login, options
          chain_proxy
        end
        
        def _usermod(*args, &block) # :nodoc:
          str = capture_str { usermod(*args, &block) }
          str.strip!
          str
        end
      end
    end
  end
end
