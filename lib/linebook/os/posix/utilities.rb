# Generated by Linecook

module Linebook
  module Os
    module Posix
      module Utilities
        # Return non-directory portion of a pathname. If a suffix is provided and
        # present, then it will be removed.
        def basename(string, suffix=nil)
          execute 'basename', string, suffix
          chain_proxy
        end
        
        def _basename(*args, &block) # :nodoc:
          str = capture_str { basename(*args, &block) }
          str.strip!
          str
        end
        
        # Concatenate and print files.
        def cat(*files)
          execute 'cat', *files
          chain_proxy
        end
        
        def _cat(*args, &block) # :nodoc:
          str = capture_str { cat(*args, &block) }
          str.strip!
          str
        end
        
        # Change the working directory, for the duration of a block if given.
        def cd(directory=nil, options={})
          if block_given?
            var = _package_.next_variable_name('cd')
            writeln %{#{var}=$(pwd)}
          end
        
          execute 'cd', directory, options
        
          if block_given?
            yield
            execute 'cd', "$#{var}"
          end
          chain_proxy
        end
        
        def _cd(*args, &block) # :nodoc:
          str = capture_str { cd(*args, &block) }
          str.strip!
          str
        end
        
        # Change the file group ownership
        def chgrp(group, *files)
          unless group.nil?
            execute 'chgrp', group, *files
          end
          chain_proxy
        end
        
        def _chgrp(*args, &block) # :nodoc:
          str = capture_str { chgrp(*args, &block) }
          str.strip!
          str
        end
        
        # Change the file modes. The mode may be specified as a String or a Fixnum. If a
        # Fixnum is provided, then it will be formatted into an octal string using
        # sprintf "%o".
        def chmod(mode, *files)
          unless mode.nil?
            if mode.kind_of?(Fixnum)
              mode = sprintf("%o", mode)
            end
            execute 'chmod', mode, *files
          end
          chain_proxy
        end
        
        def _chmod(*args, &block) # :nodoc:
          str = capture_str { chmod(*args, &block) }
          str.strip!
          str
        end
        
        # Change the file ownership.
        def chown(owner, *files)
          unless owner.nil?
            execute 'chown', owner, *files
          end
          chain_proxy
        end
        
        def _chown(*args, &block) # :nodoc:
          str = capture_str { chown(*args, &block) }
          str.strip!
          str
        end
        
        # Compare two files.
        def cmp(file1, file2, options={})
          execute 'cmp', file1, file2, options
          chain_proxy
        end
        
        def _cmp(*args, &block) # :nodoc:
          str = capture_str { cmp(*args, &block) }
          str.strip!
          str
        end
        
        # Select or reject lines common to two files.
        def comm(file1, file2, options={})
          execute 'comm', file1, file2, options
          chain_proxy
        end
        
        def _comm(*args, &block) # :nodoc:
          str = capture_str { comm(*args, &block) }
          str.strip!
          str
        end
        
        # Copy files.
        def cp(source_file, target_file, options={})
          execute 'cp', source_file, target_file, options
          chain_proxy
        end
        
        def _cp(*args, &block) # :nodoc:
          str = capture_str { cp(*args, &block) }
          str.strip!
          str
        end
        
        # Cut out selected fields of each line of a file.
        def cut(*files)
          execute 'cut', *files
          chain_proxy
        end
        
        def _cut(*args, &block) # :nodoc:
          str = capture_str { cut(*args, &block) }
          str.strip!
          str
        end
        
        # Writes the date and time.
        def date(options={})
          execute 'date', options
          chain_proxy
        end
        
        def _date(*args, &block) # :nodoc:
          str = capture_str { date(*args, &block) }
          str.strip!
          str
        end
        
        # Checks that file exists and is a directory.
        def directory?(dir)
          #  [ -d "<%= dir %>" ]
          #  
          write "[ -d \""; write(( dir ).to_s); write "\" ]\n"
        
          chain_proxy
        end
        
        def _directory?(*args, &block) # :nodoc:
          str = capture_str { directory?(*args, &block) }
          str.strip!
          str
        end
        
        # Return the directory portion of a pathname.
        def dirname(string)
          execute 'dirname', string
          chain_proxy
        end
        
        def _dirname(*args, &block) # :nodoc:
          str = capture_str { dirname(*args, &block) }
          str.strip!
          str
        end
        
        # Write arguments to standard output.
        def echo(*string)
          execute 'echo', *string
          chain_proxy
        end
        
        def _echo(*args, &block) # :nodoc:
          str = capture_str { echo(*args, &block) }
          str.strip!
          str
        end
        
        # Checks that file exists and is executable, or file is a directory that can be
        # searched.
        def executable?(file)
          #  [ -x "<%= file %>" ]
          #  
          write "[ -x \""; write(( file ).to_s); write "\" ]\n"
        
          chain_proxy
        end
        
        def _executable?(*args, &block) # :nodoc:
          str = capture_str { executable?(*args, &block) }
          str.strip!
          str
        end
        
        # Checks that file exists.
        def exists?(file)
          #  [ -e "<%= file %>" ]
          #  
          write "[ -e \""; write(( file ).to_s); write "\" ]\n"
        
          chain_proxy
        end
        
        def _exists?(*args, &block) # :nodoc:
          str = capture_str { exists?(*args, &block) }
          str.strip!
          str
        end
        
        # Convert tabs to spaces.
        def expand(*files)
          execute 'expand', *files
          chain_proxy
        end
        
        def _expand(*args, &block) # :nodoc:
          str = capture_str { expand(*args, &block) }
          str.strip!
          str
        end
        
        # Set the export attribute for variables.
        def export(key, value=nil)
          #  <% if value.nil? %>
          #  export <%= key %>
          #  <% else %>
          #  export <%= key %>=<%= quote(value) %>
          #  <% end %>
          #  
          if value.nil? 
          write "export "; write(( key ).to_s); write "\n"
          else 
          write "export "; write(( key ).to_s); write "="; write(( quote(value) ).to_s); write "\n"
          end 
        
          chain_proxy
        end
        
        def _export(*args, &block) # :nodoc:
          str = capture_str { export(*args, &block) }
          str.strip!
          str
        end
        
        # Checks that file exists and is a regular file.
        def file?(file)
          #  [ -f "<%= file %>" ]
          #  
          write "[ -f \""; write(( file ).to_s); write "\" ]\n"
        
          chain_proxy
        end
        
        def _file?(*args, &block) # :nodoc:
          str = capture_str { file?(*args, &block) }
          str.strip!
          str
        end
        
        # Filter for folding lines.
        def fold(*files)
          execute 'fold', *files
          chain_proxy
        end
        
        def _fold(*args, &block) # :nodoc:
          str = capture_str { fold(*args, &block) }
          str.strip!
          str
        end
        
        # Search a file for a pattern.
        def grep(pattern_list, *files)
          execute 'grep', pattern_list, *files
          chain_proxy
        end
        
        def _grep(*args, &block) # :nodoc:
          str = capture_str { grep(*args, &block) }
          str.strip!
          str
        end
        
        # Checks that file exists and is not empty.
        def has_content?(file)
          #  [ -s "<%= file %>" ]
          #  
          write "[ -s \""; write(( file ).to_s); write "\" ]\n"
        
          chain_proxy
        end
        
        def _has_content?(*args, &block) # :nodoc:
          str = capture_str { has_content?(*args, &block) }
          str.strip!
          str
        end
        
        # Copy the first part of files.
        def head(*files)
          execute 'head', *files
          chain_proxy
        end
        
        def _head(*args, &block) # :nodoc:
          str = capture_str { head(*args, &block) }
          str.strip!
          str
        end
        
        # Checks that file exists and is a symbolic link.
        def link?(file)
          #  [ -L "<%= file %>" ]
          #  
          write "[ -L \""; write(( file ).to_s); write "\" ]\n"
        
          chain_proxy
        end
        
        def _link?(*args, &block) # :nodoc:
          str = capture_str { link?(*args, &block) }
          str.strip!
          str
        end
        
        # Link files.
        def ln(source_file, target_file, options={})
          execute 'ln', source_file, target_file, options
          chain_proxy
        end
        
        def _ln(*args, &block) # :nodoc:
          str = capture_str { ln(*args, &block) }
          str.strip!
          str
        end
        
        # List directory contents.
        def ls(*files)
          execute 'ls', *files
          chain_proxy
        end
        
        def _ls(*args, &block) # :nodoc:
          str = capture_str { ls(*args, &block) }
          str.strip!
          str
        end
        
        # Make directories.
        def mkdir(*dirs)
          execute 'mkdir', *dirs
          chain_proxy
        end
        
        def _mkdir(*args, &block) # :nodoc:
          str = capture_str { mkdir(*args, &block) }
          str.strip!
          str
        end
        
        # Move files.
        def mv(source_file, target_file, options={})
          execute 'mv', source_file, target_file, options
          chain_proxy
        end
        
        def _mv(*args, &block) # :nodoc:
          str = capture_str { mv(*args, &block) }
          str.strip!
          str
        end
        
        # Merge corresponding or subsequent lines of files.
        def paste(*files)
          execute 'paste', *files
          chain_proxy
        end
        
        def _paste(*args, &block) # :nodoc:
          str = capture_str { paste(*args, &block) }
          str.strip!
          str
        end
        
        # Return working directory name.
        def pwd(options={})
          execute 'pwd', options
          chain_proxy
        end
        
        def _pwd(*args, &block) # :nodoc:
          str = capture_str { pwd(*args, &block) }
          str.strip!
          str
        end
        
        # Checks that file exists and is readable.
        def readable?(file)
          #  [ -r "<%= file %>" ]
          #  
          write "[ -r \""; write(( file ).to_s); write "\" ]\n"
        
          chain_proxy
        end
        
        def _readable?(*args, &block) # :nodoc:
          str = capture_str { readable?(*args, &block) }
          str.strip!
          str
        end
        
        # Remove directory entries.
        def rm(*files)
          execute 'rm', *files
          chain_proxy
        end
        
        def _rm(*args, &block) # :nodoc:
          str = capture_str { rm(*args, &block) }
          str.strip!
          str
        end
        
        # Remove directories.
        def rmdir(*dirs)
          execute 'rm', *dirs
          chain_proxy
        end
        
        def _rmdir(*args, &block) # :nodoc:
          str = capture_str { rmdir(*args, &block) }
          str.strip!
          str
        end
        
        # Stream editor.
        def sed(script, *files)
          execute 'sed', script, *files
          chain_proxy
        end
        
        def _sed(*args, &block) # :nodoc:
          str = capture_str { sed(*args, &block) }
          str.strip!
          str
        end
        
        # Set or unset options as specified. For example:
        # 
        #   set 'x' => true, 'v' => false
        # 
        # If a block is given then options will only be reset when the block completes.
        def set(options)
          if block_given?
            var = _package_.next_variable_name('set')
            patterns = options.keys.collect {|key| "-e #{key}" }.sort
            writeln %{#{var}=$(set +o | grep #{patterns.join(' ')})}
          end
        
          options.keys.sort_by {|opt| opt.to_s }.each do |opt|
            writeln %{set #{options[opt] ? '-' : '+'}o #{opt}}
          end
        
          if block_given?
            yield
            writeln %{eval "$#{var}"}
          end
          chain_proxy
        end
        
        def _set(*args, &block) # :nodoc:
          str = capture_str { set(*args, &block) }
          str.strip!
          str
        end
        
        # Sort, merge, or sequence check text files.
        def sort(*file)
          execute 'sort', *files
          chain_proxy
        end
        
        def _sort(*args, &block) # :nodoc:
          str = capture_str { sort(*args, &block) }
          str.strip!
          str
        end
        
        # Split files into pieces.
        def split(file, *options)
          execute 'split', file, *options
          chain_proxy
        end
        
        def _split(*args, &block) # :nodoc:
          str = capture_str { split(*args, &block) }
          str.strip!
          str
        end
        
        # Copy the last part of a file.
        def tail(file, options={})
          execute 'tail', file, options
          chain_proxy
        end
        
        def _tail(*args, &block) # :nodoc:
          str = capture_str { tail(*args, &block) }
          str.strip!
          str
        end
        
        # Change file access and modification times.
        def touch(*files)
          execute 'touch', *files
          chain_proxy
        end
        
        def _touch(*args, &block) # :nodoc:
          str = capture_str { touch(*args, &block) }
          str.strip!
          str
        end
        
        # Translate characters.
        def tr(string, *options)
          execute 'tr', string, *options
          chain_proxy
        end
        
        def _tr(*args, &block) # :nodoc:
          str = capture_str { tr(*args, &block) }
          str.strip!
          str
        end
        
        # Topological sort.
        def tsort(file)
          execute 'tsort', file
          chain_proxy
        end
        
        def _tsort(*args, &block) # :nodoc:
          str = capture_str { tsort(*args, &block) }
          str.strip!
          str
        end
        
        # Convert paces to tabs.
        def unexpand(*files)
          execute 'unexpand', *files
          chain_proxy
        end
        
        def _unexpand(*args, &block) # :nodoc:
          str = capture_str { unexpand(*args, &block) }
          str.strip!
          str
        end
        
        # Report or filter out repeated lines in a file.
        def uniq(*options)
          execute 'uniq', *options
          chain_proxy
        end
        
        def _uniq(*args, &block) # :nodoc:
          str = capture_str { uniq(*args, &block) }
          str.strip!
          str
        end
        
        # Unset values and attributes of variables and functions.
        def unset(*names)
          execute 'unset', *names
          chain_proxy
        end
        
        def _unset(*args, &block) # :nodoc:
          str = capture_str { unset(*args, &block) }
          str.strip!
          str
        end
        
        # Word, line, and byte or character count.
        def wc(*files)
          execute 'wc', *files
          chain_proxy
        end
        
        def _wc(*args, &block) # :nodoc:
          str = capture_str { wc(*args, &block) }
          str.strip!
          str
        end
        
        # Checks that file exists and is writable.
        def writable?(file)
          #  [ -w "<%= file %>" ]
          #  
          write "[ -w \""; write(( file ).to_s); write "\" ]\n"
        
          chain_proxy
        end
        
        def _writable?(*args, &block) # :nodoc:
          str = capture_str { writable?(*args, &block) }
          str.strip!
          str
        end
      end
    end
  end
end
