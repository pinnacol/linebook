# Generated by Linecook

module Linebook
  module Os
    # Defines Linux-compliant functionality, based on the {Linux Standard Base
    # Core Specification 4.1 }[http://refspecs.linuxfoundation.org/lsb.shtml]. See
    # the online documentation for:
    #
    # * {Commands and Utilties
    #   }[http://refspecs.linuxfoundation.org/LSB_4.1.0/LSB-Core-generic/LSB-Core-generic/cmdbehav.html]
    #
    # Posix does not specify commands for user management, but Linux does. Now
    # that users are overtly in the mix, see {How to Switch
    # Users}[link:files/HowTo/Switch%20Users.html] for picking a su policy.
    module Linux
      require 'linebook/os/posix'
      include Posix
      
      def guess_target_name(source_name)
        target_dir  = File.dirname(target_name)
        name = File.basename(source_name)
        
        _package_.next_target_name(target_dir == '.' ? name : File.join(target_dir, name))
      end
      
      def capture_script(options={})
        unless options.kind_of?(Hash)
          options = {:target_name => guess_target_name(options)}
        end
      
        target_name = options[:target_name] || guess_target_name('script')
        path = capture_path(target_name, options[:mode] || 0770) { yield }
      
        owner, group = options[:owner], options[:group]
        if owner || group
          callback 'before' do
            chown owner, group, path
          end
        end
      
        path
      end
      
      # Returns true if the group exists as determined by checking /etc/group.
      def group?(name)
        #  grep "^<%= name %>:" /etc/group >/dev/null 2>&1
        write "grep \"^"; write(( name ).to_s); write ":\" /etc/group >/dev/null 2>&1"
        chain_proxy
      end
      
      def _group?(*args, &block) # :nodoc:
        str = capture_str { group?(*args, &block) }
        str.strip!
        str
      end
      
      # Create a new group.
      def groupadd(group, options={})
        execute 'groupadd', group, options
        chain_proxy
      end
      
      def _groupadd(*args, &block) # :nodoc:
        str = capture_str { groupadd(*args, &block) }
        str.strip!
        str
      end
      
      # Delete a group.
      def groupdel(group)
        execute 'groupdel', group
        chain_proxy
      end
      
      def _groupdel(*args, &block) # :nodoc:
        str = capture_str { groupdel(*args, &block) }
        str.strip!
        str
      end
      
      # Modify a group.
      def groupmod(group, options={})
        execute 'groupmod', group, options
        chain_proxy
      end
      
      def _groupmod(*args, &block) # :nodoc:
        str = capture_str { groupmod(*args, &block) }
        str.strip!
        str
      end
      
      # Display a group.
      def groups(user)
        execute 'groups', user
        chain_proxy
      end
      
      def _groups(*args, &block) # :nodoc:
        str = capture_str { groups(*args, &block) }
        str.strip!
        str
      end
      
      # Copy files and set attributes.
      def install(source, dest, options={})
        execute 'install', source, dest, options
        chain_proxy
      end
      
      def _install(*args, &block) # :nodoc:
        str = capture_str { install(*args, &block) }
        str.strip!
        str
      end
      
      # Logs in as the specified user for the duration of a block (the current ENV
      # and pwd are reset as during a normal login).
      def login(user='root', options={})
        current = functions
        begin
          @functions = []
          
          path = capture_script(options) { yield }
          execute 'su', user, path, :l => true
        ensure
          @functions = current
        end
        chain_proxy
      end
      
      def _login(*args, &block) # :nodoc:
        str = capture_str { login(*args, &block) }
        str.strip!
        str
      end
      
      # Switches to the specified user for the duration of a block.  The current ENV
      # and pwd are preserved.
      def su(user='root', options={})
        path = capture_script(options) do
          functions.each do |function|
            writeln function
          end
          yield
        end
        execute 'su', user, path, :m => true
        chain_proxy
      end
      
      def _su(*args, &block) # :nodoc:
        str = capture_str { su(*args, &block) }
        str.strip!
        str
      end
      
      # Returns true if the user exists as determined by id.
      def user?(name)
        #  id <%= quote(name) %> >/dev/null 2>&1
        write "id "; write(( quote(name) ).to_s); write " >/dev/null 2>&1"
        chain_proxy
      end
      
      def _user?(*args, &block) # :nodoc:
        str = capture_str { user?(*args, &block) }
        str.strip!
        str
      end
      
      # Create a new user or update default new user information.
      def useradd(login, options={}) 
        execute 'useradd', login, options
        chain_proxy
      end
      
      def _useradd(*args, &block) # :nodoc:
        str = capture_str { useradd(*args, &block) }
        str.strip!
        str
      end
      
      # Delete a user account and related files.
      def userdel(login, options={}) 
        # TODO - look into other things that might need to happen before:
        # * kill processes belonging to user
        # * remove at/cron/print jobs etc. 
        execute 'userdel', login, options
        chain_proxy
      end
      
      def _userdel(*args, &block) # :nodoc:
        str = capture_str { userdel(*args, &block) }
        str.strip!
        str
      end
      
      # Modify a user account.
      def usermod(login, options={})
        execute 'usermod', login, options
        chain_proxy
      end
      
      def _usermod(*args, &block) # :nodoc:
        str = capture_str { usermod(*args, &block) }
        str.strip!
        str
      end
    end
  end
end
