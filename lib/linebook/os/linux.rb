# Generated by Linecook

module Linebook
  module Os
    # Defines Linux-compliant functionality, based on the {Linux Standard Base
    # Core Specification 4.1 }[http://refspecs.linuxfoundation.org/lsb.shtml]. 
    # See the online documentation for {Commands and Utilties
    # }[http://refspecs.linuxfoundation.org/LSB_4.1.0/LSB-Core-generic/LSB-Core-ge
    # neric/cmdbehav.html]
    #
    # == login vs su
    #
    # The login and su methods both provide a way to switch users.  Login
    # simulates a login and therefore you end up in the user home directory with
    # the ENV as setup during login. By contrast su switches users such that it
    # preserves exported ENV variables, including the pwd.
    #
    # Say you were the linecook user:
    #
    #   cd
    #   export 'A', 'a'
    #   variable 'B', 'b'
    #   echo "$(whoami):$(pwd):$A:$B"             # => linecook:/home/linecook:a:b
    #   login { echo "$(whoami):$(pwd):$A:$B" }   # => root:/root::
    #   su    { echo "$(whoami):$(pwd):$A:$B" }   # => root:/home/linecook:a:
    #
    # User-management methods in this module assume root privileges (useradd,
    # groupadd, etc) so unless you are already root, you need to wrap them in
    # login or su. In this case login is more reliable than su because some
    # systems leave the user management commands off the non-root PATH; using
    # login ensures PATH will be set for root during the block.
    #
    # For example use:
    #
    #   login { useradd 'username' }
    #
    # Rather than:
    #
    #   su { useradd 'username' }   # => may give 'useradd: command not found'
    #
    # == Permissions
    #
    # The user running the package needs the ability to su without a password,
    # otherwise login/su will choke and fail when run by 'linecook run'.  How this
    # is accomplished is a matter of policy; something each user needs to decide
    # for themselves.
    #
    # First you could run the package as root.
    #
    # Second you can grant the running user (ex 'linecook') su privileges.  This
    # can be accomplished by adding the user to the 'wheel' group and modifiying
    # the PAM config files. Afterwards all wheel users can su without a password.
    # To do so (repeat for '/etc/pam.d/su-l' if it exists):
    #
    #   vi /etc/pam.d/su
    #   # insert:
    #   #   auth       sufficient pam_wheel.so trust
    # 
    # This is the default strategy and it works in a portable way because the
    # {linux spec}[http://refspecs.linuxfoundation.org/LSB_4.1.0/LSB-Core-generic/LSB-Core-generic/cmdbehav.html]
    # requires su exists and has the necessary options.
    #
    # Third you can chuck the default login/su, reimplement them with sudo, and
    # give the user (ex 'linecook') sudo privileges.  This can be accomplished by
    # adding the user to a group (ex 'linecook') and modifying the sudo config via
    # visudo. Afterwards all the linecook users can sudo without a password.
    #
    #   visudo
    #   # insert:
    #   #   # Members of the linecook group may sudo without a password
    #   #   %linecook ALL=NOPASSWD: ALL
    #
    # See an old version of the {linebook source}[https://github.com/pinnacol/linebook/tree/b786e1e63c68f5ddf3be15851d9b423bc05e5345/helpers/linebook/os/linux]
    # for hints on how login/su could be reimplemented with sudo.  This strategy
    # was abandonded as the default because sudo is not required by the linux spec
    # and is does not come installed in many cases (ex Debian).  Moreover the
    # options needed to make this strategy work don't exist in sudo < 1.7, so even
    # systems that come with sudo could need an upgrade.
    #
    # Lastly you can chuck all of these strategies and figure out your own way.
    # Surely they exist, for example by running the packages manually and entering
    # in passwords as prompted.
    #
    module Linux
      require 'linebook/os/posix'
      include Posix
      
      def guess_target_name(source_name)
        target_dir  = File.dirname(target_name)
        name = File.basename(source_name)
        
        _package_.next_target_name(target_dir == '.' ? name : File.join(target_dir, name))
      end
      
      def capture_script(options={})
        unless options.kind_of?(Hash)
          options = {:target_name => guess_target_name(options)}
        end
      
        target_name = options[:target_name] || guess_target_name('script')
        path = capture_path(target_name, options[:mode] || 0770) { yield }
      
        owner, group = options[:owner], options[:group]
        if owner || group
          callback 'before' do
            chown owner, group, path
          end
        end
      
        path
      end
      
      # Returns true if the group exists as determined by checking /etc/group.
      def group?(name)
        #  grep "^<%= name %>:" /etc/group >/dev/null 2>&1
        write "grep \"^"; write(( name ).to_s); write ":\" /etc/group >/dev/null 2>&1"
        chain_proxy
      end
      
      def _group?(*args, &block) # :nodoc:
        str = capture_str { group?(*args, &block) }
        str.strip!
        str
      end
      
      # Create a new group.
      def groupadd(group, options={})
        execute 'groupadd', group, options
        chain_proxy
      end
      
      def _groupadd(*args, &block) # :nodoc:
        str = capture_str { groupadd(*args, &block) }
        str.strip!
        str
      end
      
      # Delete a group.
      def groupdel(group)
        execute 'groupdel', group
        chain_proxy
      end
      
      def _groupdel(*args, &block) # :nodoc:
        str = capture_str { groupdel(*args, &block) }
        str.strip!
        str
      end
      
      # Modify a group.
      def groupmod(group, options={})
        execute 'groupmod', group, options
        chain_proxy
      end
      
      def _groupmod(*args, &block) # :nodoc:
        str = capture_str { groupmod(*args, &block) }
        str.strip!
        str
      end
      
      # Display a group.
      def groups(user)
        execute 'groups', user
        chain_proxy
      end
      
      def _groups(*args, &block) # :nodoc:
        str = capture_str { groups(*args, &block) }
        str.strip!
        str
      end
      
      # Copy files and set attributes.
      def install(source, dest, options={})
        execute 'install', source, dest, options
        chain_proxy
      end
      
      def _install(*args, &block) # :nodoc:
        str = capture_str { install(*args, &block) }
        str.strip!
        str
      end
      
      # Logs in as the specified user for the duration of a block (the current ENV
      # and pwd are reset as during a normal login).
      def login(user='root', options={})
        current = functions
        begin
          @functions = []
          
          path = capture_script(options) { yield }
          execute 'su', user, path, :l => true
        ensure
          @functions = current
        end
        chain_proxy
      end
      
      def _login(*args, &block) # :nodoc:
        str = capture_str { login(*args, &block) }
        str.strip!
        str
      end
      
      # Switches to the specified user for the duration of a block.  The current ENV
      # and pwd are preserved.
      def su(user='root', options={})
        path = capture_script(options) do
          functions.each do |function|
            writeln function
          end
          yield
        end
        execute 'su', user, path, :m => true
        chain_proxy
      end
      
      def _su(*args, &block) # :nodoc:
        str = capture_str { su(*args, &block) }
        str.strip!
        str
      end
      
      # Returns true if the user exists as determined by id.
      def user?(name)
        #  id <%= quote(name) %> >/dev/null 2>&1
        write "id "; write(( quote(name) ).to_s); write " >/dev/null 2>&1"
        chain_proxy
      end
      
      def _user?(*args, &block) # :nodoc:
        str = capture_str { user?(*args, &block) }
        str.strip!
        str
      end
      
      # Create a new user or update default new user information.
      def useradd(login, options={}) 
        execute 'useradd', login, options
        chain_proxy
      end
      
      def _useradd(*args, &block) # :nodoc:
        str = capture_str { useradd(*args, &block) }
        str.strip!
        str
      end
      
      # Delete a user account and related files.
      def userdel(login, options={}) 
        # TODO - look into other things that might need to happen before:
        # * kill processes belonging to user
        # * remove at/cron/print jobs etc. 
        execute 'userdel', login, options
        chain_proxy
      end
      
      def _userdel(*args, &block) # :nodoc:
        str = capture_str { userdel(*args, &block) }
        str.strip!
        str
      end
      
      # Modify a user account.
      def usermod(login, options={})
        execute 'usermod', login, options
        chain_proxy
      end
      
      def _usermod(*args, &block) # :nodoc:
        str = capture_str { usermod(*args, &block) }
        str.strip!
        str
      end
    end
  end
end
