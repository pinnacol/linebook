require 'erb'

# Generated by Linecook, do not edit.
module Linebook
  module Shell
    module Posix
      # Encloses the arg in quotes ("").
      def quote(arg)
        "\"#{arg}\""
      end
      
      # Returns true if the arg is not an option, and is not already quoted (either
      # by quotes or apostrophes).  The intention is to check whether an arg
      # _should_ be quoted.
      def quote?(arg)
        arg[0] == ?- || quoted?(arg) ? false : true
      end
      
      # Returns true if the arg is quoted (either by quotes or apostrophes).
      def quoted?(arg)
        arg =~ /\A".*"\z/ || arg =~ /\A'.*'\z/ ? true : false
      end
      
      # Returns true if the obj converts to a string which is whitespace or empty.
      def blank?(obj)
        # shortcut for nil...
        obj.nil? || obj.to_s.strip.empty?
      end
      
      def nest_opts(opts, default={})
        opts = default if opts.nil? || opts == true
        opts && block_given? ? yield(opts) : opts
      end
      
      # Returns the current indentation string.
      def current_indent
        @current_indent ||= ""
      end
      
      def outdent_ids
        @outdent_ids ||= []
      end
      
      # Indents the output of the block.  See current_indent.
      def indent(indent='  ', &block)
        @current_indent = current_indent + indent
        str = capture(&block)
        @current_indent.chomp! indent
        
        unless str.empty?
          str.gsub!(/^/, indent)
          
          if current_indent.empty?
            outdent_ids.each do |id|
              str.gsub!(/#{id}(\d+):(.*?)#{id}/m) do
                $2.gsub!(/^.{#{$1.to_i}}/, '')
              end
            end
            outdent_ids.clear
          end
          
          target.puts str
        end
        
        self
      end
      
      # Outdents a section of text indented by indent.
      def outdent(id=nil)
        if current_indent.empty?
          yield
        else
          id ||= ":outdent_#{outdent_ids.length}:"
          outdent_ids << id
          
          target << "#{id}#{current_indent.length}:#{rstrip}"
          yield
          target << "#{id}#{rstrip}"
        end
        
        self
      end
      
      attr_accessor :cmd_prefix
      
      def with_cmd_prefix(prefix)
        current = cmd_prefix
        begin
          self.cmd_prefix = prefix
          yield
        ensure
          self.cmd_prefix = current
        end
      end
      
      attr_accessor :cmd_suffix
      
      def with_cmd_suffix(suffix)
        current = cmd_suffix
        begin
          self.cmd_suffix = suffix
          yield
        ensure
          self.cmd_suffix = current
        end
      end
      
      # Adds a check that ensures the last exit status is as indicated. Note that no
      # check will be added unless check_status_function is added beforehand.
      def check_status(expect_status=0, fail_status='$?')
        @check_status ||= false
        
        #  <% if @check_status %>
        #  check_status <%= expect_status %> $? <%= fail_status %> $LINENO
        #  
        #  <% end %>
        if @check_status 
        _erbout.concat "check_status "; _erbout.concat(( expect_status ).to_s); _erbout.concat " $? "; _erbout.concat(( fail_status ).to_s); _erbout.concat " $LINENO\n"
        _erbout.concat "\n"
        end ;
        self
      end
      
      def _check_status(*args, &block) # :nodoc:
        capture { check_status(*args, &block) }
      end
      
      # Adds the check status function.
      def check_status_function()
        @check_status = true
        #  check_status () { if [ $2 -ne $1 ]; then echo "[$2] $0:${4:-?}"; exit $3; else return $2; fi }
        #  
        _erbout.concat "check_status () { if [ $2 -ne $1 ]; then echo \"[$2] $0:${4:-?}\"; exit $3; else return $2; fi }\n"
        self
      end
      
      def _check_status_function(*args, &block) # :nodoc:
        capture { check_status_function(*args, &block) }
      end
      
      # Execute a command and check the output status.  Arguments are quoted with ""
      # unless they begin with '-' or are already quoted.
      def cmd(cmd, *args)
        args.compact!
        args = args.collect! {|arg| arg[0] == ?- || quoted?(arg) ? arg : quote(arg) }
        args.unshift(cmd)
        #  <%= cmd_prefix %><%= args.join(' ') %><%= cmd_suffix %>
        #  
        #  <% check_status %>
        _erbout.concat(( cmd_prefix ).to_s); _erbout.concat(( args.join(' ') ).to_s); _erbout.concat(( cmd_suffix ).to_s)
        _erbout.concat "\n"
        check_status ;
        self
      end
      
      def _cmd(*args, &block) # :nodoc:
        capture { cmd(*args, &block) }
      end
      
      # Writes a comment
      def comment(str)
        #  # <%= str %>
        #  
        _erbout.concat "# "; _erbout.concat(( str ).to_s); _erbout.concat "\n"
        self
      end
      
      def _comment(*args, &block) # :nodoc:
        capture { comment(*args, &block) }
      end
      
      # Exports a list of variables.
      def export(env=[])
        #  <% env.to_a.each do |(key, value)| %>
        #  export <%= key %>=<%= value %>
        #  <% end %><% if block_given? %>
        #  <% indent { yield } %>
        #  <% unset(*env.collect {|(k,v)| k }) %>
        #  <% end %>
        #  
        #  
        env.to_a.each do |(key, value)| 
        _erbout.concat "export "; _erbout.concat(( key ).to_s); _erbout.concat "="; _erbout.concat(( value ).to_s); _erbout.concat "\n"
        end ;  if block_given? 
        indent { yield } 
        unset(*env.collect {|(k,v)| k }) 
        end 
        _erbout.concat "\n"
        self
      end
      
      def _export(*args, &block) # :nodoc:
        capture { export(*args, &block) }
      end
      
      # Makes a heredoc statement surrounding the contents of the block.  Options:
      # 
      #   delimiter   the delimiter used, by default HEREDOC_n where n increments
      #   outdent     add '-' before the delimiter
      #   quote       quotes the delimiter
      def heredoc(options={})
        delimiter = options[:delimiter] || begin
          @heredoc_count ||= -1
          "HEREDOC_#{@heredoc_count += 1}"
        end
        #  <<<%= options[:outdent] ? '-' : ' '%><%= options[:quote] ? "\"#{delimiter}\"" : delimiter %><% outdent(" # :#{delimiter}:") do %>
        #  <% yield %>
        #  <%= delimiter %><% end %>
        #  
        #  
        _erbout.concat "<<"; _erbout.concat(( options[:outdent] ? '-' : ' ').to_s); _erbout.concat(( options[:quote] ? "\"#{delimiter}\"" : delimiter ).to_s);  outdent(" # :#{delimiter}:") do ; _erbout.concat "\n"
        yield 
        _erbout.concat(( delimiter ).to_s);  end 
        _erbout.concat "\n"
        self
      end
      
      def _heredoc(*args, &block) # :nodoc:
        capture { heredoc(*args, &block) }
      end
      
      def not_if(cmd, &block)
        only_if("! #{cmd}", &block)
        self
      end
      
      def _not_if(*args, &block) # :nodoc:
        capture { not_if(*args, &block) }
      end
      
      def only_if(cmd)
        #  if <%= cmd %>
        #  then
        #  <% indent { yield } %>
        #  fi
        #  
        #  
        _erbout.concat "if "; _erbout.concat(( cmd ).to_s); _erbout.concat "\n"
        _erbout.concat "then\n"
        indent { yield } 
        _erbout.concat "fi\n"
        _erbout.concat "\n"
        self
      end
      
      def _only_if(*args, &block) # :nodoc:
        capture { only_if(*args, &block) }
      end
      
      # Sets the options to on (true) or off (false) as specified.
      def set_options(options)
        #  <% options.keys.sort_by {|opt| opt.to_s }.each do |opt| %>
        #  set <%= options[opt] ? '-' : '+' %>o <%= opt %>
        #  <% end %>
        options.keys.sort_by {|opt| opt.to_s }.each do |opt| 
        _erbout.concat "set "; _erbout.concat(( options[opt] ? '-' : '+' ).to_s); _erbout.concat "o "; _erbout.concat(( opt ).to_s); _erbout.concat "\n"
        end ;
        self
      end
      
      def _set_options(*args, &block) # :nodoc:
        capture { set_options(*args, &block) }
      end
      
      # Unsets a list of variables.
      def unset(*keys)
        #  <% keys.each do |key| %>
        #  unset <%= key %>
        #  <% end %>
        keys.each do |key| 
        _erbout.concat "unset "; _erbout.concat(( key ).to_s); _erbout.concat "\n"
        end ;
        self
      end
      
      def _unset(*args, &block) # :nodoc:
        capture { unset(*args, &block) }
      end
    end
  end
end
